https://karpov.courses/docker
https://ru.hexlet.io/courses/docker-basics

---

**Docker** — инструмент, который позволяет деплоить приложения в песочнице (контейнерах) для запуска на целевой операционной системе. Ключевое преимущество — позволяет пользователям упаковать приложение со всеми его зависимостями в стандартизированный модуль для разработки.
### ...

- **Images (образы)** — cхемы нашего приложения, которые являются основой контейнеров.

- **Containers (контейнеры)** — cоздаются на основе образа и запускают само приложение.

- **Docker Daemon (демон Докера)** — фоновый сервис, запущенный на хост-машине, который отвечает за создание, запуск, контроль и уничтожение контейнеров, а также за создание и хранение образов. Процесс, который запущен на операционной системе, с которой взаимодействует клиент.

- **Docker Client (клиент Докера)** — утилита командной строки, которая позволяет пользователю взаимодействовать с демоном. Общается с ним по HTTP. По умолчанию это соединение устанавливается через сокет домена Unix, но также может использоваться TCP-сокет для поддержки соединений с удаленными клиентами или дескриптор файла для сокетов, управляемых systemd. Так как все операции обмена данными выполняются по протоколу HTTP, можно без затруднений организовать соединение с удаленными демонами Docker и разработать привязки (bindings) к нужному языку программирования.

- **Docker Host**

- **Docker Registry**

---

- **Docker Compose** — инструмент для определения и запуска многоконтейнерных приложений.

- **Docker Machine** позволяет создавать Докер-хосты на своем компьютере, облачном провайдере или внутри дата-центра.

- **Docker Swarm** — нативное решение для кластеризации.

---

- `.yaml`, `.yml`

- Контейнер существует, пока существует его основной процесс.

- `.dockerignore` разрешает маунтить содержащие себя файлы.

- В `Dockerfile` разрешено писать и в нижнем регистре, но так никто не делает.

- Каталоги могут содержать файлы из нескольких файловых систем, но если двум файлам в точности соответствует один и тот же путь, то файл, смонтированный самым последним, скроет все ранее монтированные файлы.
- Docker поддерживает несколько различных реализаций UnionFS, включая AUFS, Overlay, devicemapper, BTRFS и ZFS. Реализацию, используемую в конкретной системе, можно определить командой `docker info` (см. содержимое заголовка «Storage Driver»). Файловую систему можно заменить, но это рекомендуется только в тех случаях, когда вы точно знаете, что делаете, и хорошо знакомы со всеми преимуществами и недостатками используемых файловых систем.
- Для контейнеров Docker использует файловую систему `UnionFS (Union File System)`, которая позволяет монтировать несколько файловых систем (перекрывая друг друга) в общую иерархию, которая выглядит как единая файловая система (т.н. `каскадно-объединенное монтирование (union mount)`). Файловая система конкретного образа смонтирована как уровень только для чтения, а любые изменения в работающем контейнере происходят на уровне с разрешенной записью, монтируемого поверх основной файловой системы образа. Поэтому Docker при поиске изменений в работающей системе должен рассматривать только самый верхний уровень, на котором возможна запись. 
- Образы Docker состоят из нескольких уровней (layers). Каждый уровень представляет собой защищенную от записи файловую систему. Для каждой инструкции в Dockerfile создается свой уровень, который размещается поверх предыдущих уровней. Во время преобразования образа в контейнер (командой `docker run` или `docker create`) механизм Docker выбирает нужный образ и добавляет на самом верхнем уровне файловую систему с возможностью записи (одновременно с этим инициализируются разнообразные параметры настройки, такие как IP-адрес, имя, идентификатор и ограничения ресурсов). Поскольку ненужные уровни значительно увеличивают размеры образов (а для файловой системы AUFS установлен строгий лимит, равный 127 уровням), во многих файлах Dockerfile можно обнаружить попытку свести к минимуму количество уровней посредством записи нескольких команд Unix в одной инструкции RUN. Каждая инструкция в Dockerfile приводит к появлению нового уровня (layer) образа, который также может участвовать в запуске контейнера. Новый уровень создается во время запуска контейнера с использованием образа предыдущего уровня при выполнении соответствующей инструкции Dockerfile и с сохранением нового образа. После успешного завершения выполнения инструкции Dockerfile вспомогательный контейнер удаляется, если в команде не был задан аргумент `--rm=false`. Так как результатом выполнения каждой инструкции является создание статического образа – в сущности, это файловая система и некоторые метаданные, – все активные процессы в данной инструкции будут завершены.
- Слои переиспользуются. Для ускорения создания образов Docker выполняет кэширование каждого уровня. Кэширование очень важно для повышения эффективности рабочих операций, но не всегда его применение имеет смысл. Например, 

![[problem-of-cache-usage.png]]

![[reusage-layers-1.png]]
![[reusage-layers-2.png]]
![[reusage-layers-3.png]]

```zsh
docker history <image_name>:<optional_tag>  # посмотреть весь набор уровней, формирующих образ
```


### А НА МОЁМ ВСЕ РАБОТАЕТ!

По умолчанию для запуска бинарного файла Docker требуются привилегии суперпользователя. Ситуацию можно исправить, добавив нужного пользователя в группу docker. Для Ububtu и других диструбутивов Linux:
```zsh
sudo groupadd docker
sudo usermod -aG docker $USER
# Может выдать `groupadd: group 'docker' already exists`. Это нормально.
id -nG
sudo service docker restart
```

```zsh
sudo chmod 666 /var/run/docker.sock
```


```zsh
docker run --rm --platform=linux/amd64 kcoursedocker/task-1.1
```
или
1. Find and open `.bashrc` or `.zshenv`.
2. Add `export DOCKER_DEFAULT_PLATFORM=linux/amd64` in the bottom of the files.
3. Launch `source .bashrc` or `source .zshenv`


### ПРОВЕРКА

```zsh
docker run hello-world
docker run debian echo "Hello World"
```


### ИНСПЕКЦИЯ

```zsh
docker version
```

```zsh
docker info
```

---

```zsh
docker ps  # выводит на экран список всех запущенных контейнеров
```
	-a  # + список всех контейнеров, которые мы запускали
    -q  # только айдишники
    -s  # + размер контейнеров
    -f <status>=<exited>  # фильтрация на основе предоставленных условий

---

```zsh
docker inspect <container_name>|<container_id>  # объёмная информация о контейнере
```
	--format {{.<KeysThroughDots>}}  # для поиска нужной информации

---

```zsh
docker diff <container_name>|<container_id>  # посмотреть список файлов, измененных в работающем контейнере
```

---

```zsh
docker logs <container_name>|<container_id>  # будет выведен список всех событий, произошедших внутри заданного контейнера
```
	-f, --follow  # follow log output
	--since string  # show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
	-n, --tail string  # number of lines to show from the end of the logs (default "all")
	-t, --timestamps  # show timestamps
	--until string  # show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)

```zsh
docker inspect --format "{{.LogPath}}" <container_name>|<container_id>
```

---

```zsh
docker system df
```


### ЗАПУСК КОНТЕЙНЕРОВ И ОБРАЗОВ

![[docker-container-life.png]]

```zsh
docker start <container_name>|<container_id> ...  # повторно запустить остановленный(ые) контейнер
```

```zsh
docker pause <container_name>|<container_id> ...  # поставить на паузу запущенный(ые) контейнер
docker unpause <container_name>|<container_id> ...  # запустить поставленный на паузу запущенный(ые) контейнер
```

```zsh
docker stop <container_name>|<container_id> ...  # остановить запущенный(ые) контейнер
```

---

```zsh
docker run <image_name>|<image_id>
docker run <image_name>|<image_id> <command>  # содержимое CMD заменяется на <command>
docker run <image_name>|<image_id> bash  # запуститься, отработает и выйдет

docker run -i <image_name>|<image_id>  # -i оставляет STDIN открытым
docker run -i <image_name>|<image_id> bash
docker run -it <image_name>|<image_id>
docker run -it <image_name>|<image_id> bash
docker run -it <image_name>|<image_id> bash  # не сработает, если ENTRYPOINT ["bash"]
docker run -it <image_name>|<image_id> -c 'bash'  # сработает, так как явно говорим ENTRYPOINT ["bash"], что нужно запустить такую вот комманду
docker run -it --entrypoint=bash <image_name>|<image_id>
```
	-h <host_name>  # задать имя хосту
    --name <container_name>  # задать имя контейнеру
    --rm  # контейнер будет автоматически удаляться при завершении
    -d  # открепить терминал (detach mode - чтобы терминал не был прикреплен к запущенному контейнеру (можно будет спокойно закрыть терминал, а контейнер продолжит работу)
    --link <linked_container>:<master_container>  # связать два контейнера (устаревшая практика)
    --net=(none, bridge (by default), host, custom)
    -v </path/to/host/dir>:</path/to/container/dir>
    --volumes-from <existing_container>  # для установления соединения между новым контейнером и, например, каталогом базы данных Redis
    -w  # указать рабочую директорию внутри контейнера
    -e ENV="VALUE"
    --env-file
    -p <host-port>:<container-port>  # сообщает механизму Docker о необходимости перенаправления порта хоста на порт в контейнере. Можно прокинуть несколько портов за раз, указав -p такое же количество раз (например, -p 6379:6379 -p 6380:6379);
    -p <IP_адрес_на_компьютере>:<порт_на_компьютере>:<порт_в_контейнере>
    -P  # механизм Docker должен автоматически выбрать свободный порт для перенаправления с хоста в контейнер. Главное преимущество использования аргумента -P заключается в устранении дополнительного уровня ответственности за корректное назначение портов, что особенно важно при наличии нескольких контейнеров с портами, открытыми для общего доступа.

```zsh
docker start <container_name>|<container_id>
docker exec <container_name>|<container_id> <command>

docker exec -i <container_name>|<container_id>
docker exec -i <container_name>|<container_id> bash
docker exec -it <container_name>|<container_id>
docker exec -it <container_name>|<container_id> bash
docker exec -it <container_name>|<container_id> bash -c '<command>'
```

You can detach from the container and leave it running with `CTRL-p` `CTRL-q`.

### УДАЛЕНИЕ КОНТЕЙНЕРОВ И ОБРАЗОВ

```zsh
docker rm <container_name>|<container_id> ...  # удалить заданный(ые) контейнер
```
	-v  # позволяет удалить все тома (разделы), управляемые Docker, на которые не ссылаются какие-либо другие контейнеры

```zsh
docker rm -v $(docker ps -aqf status=exited) 
```

---

```zsh
docker rmi <image_name>|<image_id> ...
docker image rm <image_name>|<image_id> ...
```


### ОБРАЗЫ, СОЗДАТЬ ОБРАЗ НА ОСНОВЕ КОНТЕЙНЕРА

```zsh
docker images  # посмотреть список образов в системе
docker image ls
```

---

```zsh
docker commit <container_name>|<container_id> <user_name>/<new_image_name>:<version>  # для превращения контейнера в образ, при этом не имеет значения, работает контейнер или он остановлен
```


### СОЗДАТЬ КОНТЕЙНЕР НА ОСНОВЕ ОБРАЗА

```zsh
docker create <image_name>
```

---

```zsh
cd /path/to/dir/with/dockerfile  # перейти к контексту создания образа
docker build .  # cоздать образ на основе Dockerfile
```
	-t <user_name>/<new_image_name>:<optional_tag> <path>  # создать образ с именем и тегом
	-f Dockerfile.dev  # если нет прямого указания, то Docker попытается найти файл с именем Dockerfile в корневом каталоге контекста
    --no-cache  # для отмены кэширования
    --target string  # set the target build stage to build
    -q,--quiet  # suppress the build output and print image ID on success
    --platform stringArray  # set target platform for build

Следует отметить, что при запуске команды `docker build` Docker считывает инструкцию FROM и пытается скачать заданный образ, если его нет в локальной системе. Если такой образ существует локально, Docker использует его без проверки доступности новой версии. Это означает, что команда `docker build` не может гарантировать, что вызываемый образ соответствует самой новой версии, поэтому необходимо явно выполнить команду `docker pull` для всех родительских образов или удалить их, чтобы команда `docker build` загрузила самые новые их версии.

---

**Контекст создания** – это набор локальных файлов и каталогов, к которым можно обращаться из инструкций ADD и/или COPY в Dockerfile и которые обычно определяются как путь к нужному каталогу.

Все файлы и каталоги, расположенные по указанному пути, формируют контекст создания образа и передаются в демон Docker как часть процесса создания.

В тех случаях, когда контекст не определен, – если задан только URL для Dockerfile или содержимое Dockerfile передается по программному каналу из стандартного потока ввода (STDIN), – контекст создания данного образа считается пустым.

**Неследует использовать `/` в качестве контекста создания образа.** Поскольку контекст создания образа полностью включается в `tar-архив` и передается в демон Docker, не используйте для этой цели каталога, в котором содержится большое количество файлов.

Если задан URL, начинающийся с `http` или `https`, то предполагается, что это прямая ссылка на Dockerfile. В качестве контекста создания образа разрешается указывать `git-репозиторий`. В этом случае клиент Docker создает клон такого репозитория и всех подчиненных модулей во временном каталоге, который затем передается в демон Docker как контекст создания образа. Docker воспринимает контекст как git-репозиторий, если переданный путь начинается с префиксов `github.com/`, `git@` или `git://`. 

Кроме того, клиент Docker способен принимать входные данные из стандартного потока ввода STDIN, если в команде указать аргумент `-` вместо контекста создания образа. Входными данными может быть либо Dockerfile без контекста (например, `docker build - < Dockerfile`), либо архивный файл, содержащий контекст, в том числе и Dockerfile (например, `docker build - < context.tar.gz`). Архивные файлы могут передаваться в формате `tar.gz`, `xz` или `bzip2`.

---

```zsh
docker tag <source_image> <target_image>
```


### РАБОТА С РЕЕСТРАМИ

![[docker-registry-1.png]]
![[docker-registry-2.png]]
![[docker-registry-3.png]]

Для хранения образов применяется иерархическая система.

- **Реестр (registry)** – сервис, отвечающий за хранение и распространение образов. По умолчанию используется реестр Docker Hub.
- **Репозиторий (repository)** – набор взаимосвязанных образов (обычно представляющих различные версии одного приложения или сервиса).
- **Тег (tag)** – алфавитно-цифровой идентификатор, присваиваемый образам внутри репозитория (например, 14.04 или stable).

```zsh
docker login  # чтобы локально залогиниться
docker logout  # чтобы локально разлогиниться
```

Cкачать образ из реестра (если не указывать конкретную версию, то клиент по умолчанию использует `latest`)
```zsh
docker pull <user_name>/<image_name>:<tag>
```

Залить образ в реестр
```zsh
docker push <user_name>/<image_name>
```

- **Base images (базовые образы)** — образы, которые не имеют родительского образа. Обычно это образы с операционной системой, такие как ubuntu, busybox или debian.
- **Child images (дочерние образы)** — образы, построенные на базовых образах и обладающие дополнительной функциональностью.

- **Официальные образы** — образы, которые официально поддерживаются командой Docker. Обычно в их названии одно слово. В списке выше python, ubuntu, busybox и hello-world — базовые образы.
- **Пользовательские образы** — образы, созданные простыми пользователями вроде меня и Вас. Они построены на базовых образах. Обычно, они называются по формату `user/image-name`.

- Имена, начинающиеся с текстовой строки и слеша (/), такие как amouat/revealjs, принадлежат пространству имен `user`.
- Имена, подобные debian и ubuntu, без префиксов и слешей, принадлежат пространству имен `root`, управляемому компанией Docker Inc. и зарезервированному для официальных образов широко распространенных программ и дистрибутивов, доступных для загрузки с Docker Hub.
- Имена с префиксами в виде имени хоста или IP-адреса представляют образы, хранящиеся в сторонних реестрах (не в Docker Hub).

```zsh
docker search <image_name>
```


### BIND MOUNTING, VOLUME

**Тома (volumes)** – это файлы или каталоги, которые смонтированы непосредственно на хосте и не являются частью каскадно-объединенной файловой системы. Это означает, что другие контейнеры могут совместно использовать их, и все изменения будут сразу же фиксироваться в файловой системе хоста. Существуют два способа объявления каталога как тома: использование инструкции `VOLUME` в `Dockerfile` или включение флага `-v` в команду `docker run`.

```zsh
docker run -v /data test/webserver
```

По умолчанию заданный каталог или файл будет смонтирован на хосте внутри каталога, в котором был установлен Docker (обычно это каталог `/var/lib/docker/`). В качестве точки монтирования можно определить любой другой каталог хоста в команде `docker run`
```zsh
docker run -d -v /host/dir:/container/dirtest/webserver
```

В файле `Dockerfile` определить каталог хоста как точку монтирования невозможно по причинам, связанным с обеспечением переносимости и безопасности (заданный файл или каталог может отсутствовать на других системах, а контейнерам нельзя предоставлять возможность монтирования критически важных файлов, подобных `/etc/passwd`, без явно определенных прав доступа к ним).

```zsh
docker run --rm --volumes-from myredis -v $(pwd)/backup:/backup \
debian cp /data/dump.rdb /backup/
```
Аргумент `-v` использован для монтирования известного нам существующего каталога хоста, а аргумент `--volumes-from` – для установления соединения между новым контейнером и каталогом базы данных Redis. Важно отметить, что этот способ работает вне зависимости от того, активен ли в текущий момент контейнер, содержащий тома.

При запуске контейнера из образа Docker скопирует все файлы из каталога тома в образе в соответствующий том контейнера. Но этого не произойдет, если в качестве тома задан существующий каталог хоста (чтобы случайно не уничтожить файлов, хранящихся в файловой системе хоста).

![[bind-mount, volume, tmpfs.png]]

**Volumes vs. Bind mount**
- Volumes не зависят от хоста;
- Volumes более безопасны;
- Volumes находятся в специально отведенном месте;
- Volumes позволяют связывать только папки.

**Bind mount**
```zsh
docker run -v,--volume <полный_путь_на_хосте>:<полный_путь_в_контейнере> <образ>
```

**Volume**
```zsh
docker run -v <название_вольюма>:<полный_путь_в_контейнере> <образ>
```

**Readonly режим**
```zsh
docker run -v <полный_путь_на_хосте>:<полный_путь_в_контейнере>:ro <образ>
docker run -v <полный_путь_на_хосте>:<полный_путь_в_контейнере> --user=$(id -u) <образ>
```

---

```zsh
docker volume
```
	create <volume-name>
	ls
	rm <volume-name>
	prune -a  # удалить вольюмы, которые не используются контейнерами
	inspect <volume-name>

---

```zsh
docker inspect -f {{.Mounts}} <container_name|container_id>
```


### NET

```zsh
ARG=$(docker run -d -P <image_name>)
docker port ARG <port>
```

---

```zsh
docker network
```
	connect <network> <container>  # connect a container to a network
	create <network>  # create a network
	disconnect <network> <container>  # disconnect a container from a network
	inspect <network>  # display detailed information on one or more networks
	ls  # list networks
	prune  # remove all unused networks
	rm <network> ...  # remove one or more networks

Базовые сети Docker:
- `none` — containers in such network lack a network interface. Мы имеем возможность только на петлю.
- `host` — the `host` network adds a container on the hosts network stack. You’ll find the network configuration inside the container is identical to the host. Можно не указывать порты.
- `bridge` — by default. С помощью IP-адресов можно общаться как среди контейнеров в этой подсети, так и делать запросы с хоста.

Взаимодействие между контейнерами осуществляется на уровне протокола IP.

![[docker-net.png]]

Если указать IP адрес, который получил ваш компьютер при подключении к Wi-Fi, то на localhost веб-сервис не будет доступен.

Если поднять два контейнера на одинаковом порту, но указать разные IP адреса, то все будет нормально.

— Можно ли присоединиться к нескольким докеровским сетям? 
— **Да.**

`0.0.0.0` — именно на этом адресе поднимается контейнер по умолчанию. Работает на всех IP-адресах.

```zsh
docker inspect --format "{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}" <container_name|id>
```

![[docker-dns.png]]
В кастомных сетях имя контейнера становится аналогом DNS-имени.


### MULTI-STAGE BUILDS

![[docker-multi-stage-builds.png]]

Помогает избавиться от лишнего для финального образа (оставив все в первом, сгенерировав нужное для второго). Таким образом можно решать проблемы компиляции.


### ...

![[cmd_vs_entrypoint.png]]

---

```zsh
docker cp <host/path/> <container-name>:/<container/path/>
docker cp <container-name>:/<container/path/> <host/path/> 
```

---

```zsh
docker pull docker
docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock docker
```

---







---
---

Docker импортирует несколько переменных среды из контейнера-адресата. Такое функциональное свойство может быть весьма удобным, но о нем следует помнить, когда вы используете переменные среды для хранения секретной информации, например маркеров прикладных программных интерфейсов или паролей к базам данных.
По умолчанию контейнеры могут обмениваться информацией друг с другом вне зависимости от того, было ли установлено соединение в явной форме. Если нужно запретить эту возможность, воспользуйтесь аргументами --icc=false и --iptables при запуске демона Docker. В этом случае при установлении соединения Docker будет применять правила Iptables, чтобы разрешить контейнерам обмен информацией через любые порты, которые были объявлены открытыми.
К сожалению, соединения Docker в их текущем состоянии имеют ряд недостатков. Возможно, самым существенным недостатком является их статичность – несмотря на то что при перезапуске контейнеров соединения должны сохраняться, они не обновляются, если контейнер-адресат заменен. Кроме того, контейнер-адресат обязательно должен быть инициализирован раньше управляющего контейнера, то есть двунаправленное соединение установить невозможно.

DOCKER COMPOSE
$ docker-compose version
$ docker-compose build
$ docker-compose up
$ docker-compose stop
$ docker-compose down
$ docker-compose ps
$ docker-compose run --rm megascript bash

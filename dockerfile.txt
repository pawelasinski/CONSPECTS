# Dockerfile – это обычный текстовый файл, содержащий набор операций, которые могут быть использованы для создания Docker-образа.

# В инструкциях RUN, CMD и ENTRYPOINT допускается использование как формата командной оболочки, так и формата exec.

# Комментарии в файлах Dockerfile записываются с помощью символа # в самом начале строки.


FROM <image_name>:<version>                        # определяет базовый образ ОС, строчка является строго обязательной и строго первой для всех Dockerfile

MAINTAINER Pawel Asinski p.asinsky@syberry.com     # определяет информацию, позволяющую связаться с автором данного образа

LABEL version="1.0"

ARG USER=<user_name>
ARG UID=1000
ARG GID=1000
USER ${UID}:${GID}                                 # задает пользователя (по имени или по идентификатору UID). Идентификаторы UID одинаковы на хосте и в контейнере, но имена пользователей могут присваиваться различным идентификаторам UID, что может приводить к затруднениям при установке прав доступа

WORKDIR </path/to/workdir>                         # инструкцию можно использовать несколько раз. Допускается указание относительных путей, при этом итоговый путь определяется относительно ранее указанного рабочего каталога WORKDIR

RUN <executable> <param1> <param2>                 # определяет команды, выполняемые в командной оболочке внутри данного образа

ARG <value>
ENV <ENV_VAR> ${<value>} 
ENV <ENV_VAR>=${<value>}                           # определяет переменные среды внутри образа. На эти переменные можно ссылаться в последующих инструкциях. Определенные в этой инструкции переменные будут доступными также и внутри образа

ADD                                                         # копирует файлы из контекста создания или из удаленных URL-ссылок в создаваемый образ. Если архивный файл добавляется из локального пути, то он будет автоматически распакован
COPY </source/path/of/host> </target/path/of/image>         # копирует файл из файловой системы хоста в файловую систему образа. Можно использовать шаблонные символы для определения нескольких файлов или каталогов. Невозможно указать путь «источника», расположенного вне пределов контекста создания
copy ["</source/path/of/host>", "</target/path/of/image>"]  # формат JSON-массива обязателен, если путь содержит пробелы

VOLUME </path/to/container/dir>                    # определение каталога как тома внутри контейнера. В файле Dockerfile определить каталог хоста как точку монтирования невозможно по причинам, связанным с обеспечением переносимости и безопасности (заданный файл или каталог может отсутствовать на других системах, а контейнерам нельзя предоставлять возможность монтирования критически важных файлов, подобных /etc/passwd, без явно определенных прав доступа к ним). Чрезвычайно важно помнить о том, что любая инструкция, расположенная после инструкции VOLUME в Dockerfile, не произведет никаких изменений в этом томе.

EXPOSE <port_number>                               # cообщает механизму Docker о том, что в данном контейнере будет существовать процесс, прослушивающий заданный порт или несколько портов. Механизм Docker использует эту информацию при установлении соединения между контейнерами или при открытии портов для общего доступа. Но сама по себе инструкция EXPOSE не оказывает никакого воздействия на сетевую среду. Не прокидывает порты на хост.


ENTRYPOINT ["executable"]                          # инструкция позволяет определить выполняемый файл, который будет вызываться для обработки любых аргументов, переданных в команду docker run, а также по умолчанию или любых инструкций CMD. Инструкции ENTRYPOINT часто используются для организации скриптов запуска, которые инициализируют переменные и сервисы перед обработкой всех передаваемых в образ аргументов
CMD ["executable", "param1", "param2"]             # запускает заданную инструкцию во время инициализации контейнера. Если была определена инструкция ENTRYPOINT, то заданная здесь инструкция будет интерпретироваться как аргумент для ENTRYPOINT (в этом случае необходимо использовать формат exec). Инструкция CMD замещается любыми аргументами, указанными в команде docker run после имени образа. В действительности выполняется только самая последняя инструкция CMD, а все предыдущие инструкции CMD будут отменены (в том числе и содержащиеся в основных образах)

# test_start/entry -> ENTRYPOINT ["curl", "-I", "https://karpov.courses/"]
# test_start/cmd -> CMD ["curl", "-I", "https://karpov.courses/"]
# test_start/entry_and_cmd -> ENTRYPOINT ["curl"]
#                             CMD ["-I", "https://karpov.courses/"]

# ENTRYPOINT: docker run --rm test_start/entry www.google.com == curl -I https://karpov.courses/ www.google.com
# CMD: docker run --rm test_start/cmd google.com
# CMD: docker run --rm test_start/cmd curl google.com
# ENTRYPOINT + CMD: docker run --rm test_start/entry_and_cmd == curl -I https://karpov.courses/
# ENTRYPOINT + CMD: docker run --rm test_start/entry_and_cmd google.com == curl google.com


ONBUILD ["executable", "param1", "param2"]  # определяет инструкцию, которая должна выполняться позже, когда данный образ будет использоваться как основной уровень для другого образа
